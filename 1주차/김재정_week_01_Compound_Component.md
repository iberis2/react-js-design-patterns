## **1. Compound Component ?**

여러 개의 자식 컴포넌트들이 하나의 부모 컴포넌트와 협력하여 동작하는 패턴이다. 이 패턴에서 부모 컴포넌트는 **상태와 로직을 관리**하고, 자식 컴포넌트들은 부모로부터 필요한 데이터나 상태를 **Context**(또는 Props)를 통해 받아와서 자신의 역할에 맞게 동작 한다.

이 패턴의 핵심은, **컴포넌트 간의 상호작용을 자연스럽게 연결**하는 것, 자식 컴포넌트는 부모 컴포넌트와 데이터를 공유하며 독립적으로 동작하지만, 서로가 협력하여 하나의 일관된 기능을 제공 한다.

## 2. 이 패턴이 필요한 이유와 해결하려는 문제

### **2-1 컴포넌트 간 상호작용의 일관성**

여러 자식 컴포넌트가 하나의 큰 기능을 함께 구현해야 하는 경우, 각 컴포넌트가 독립적으로 동작하되 부모 컴포넌트를 통해 **상태와 로직이 일관성 있게** 전달되는 것이 중요하다. 

예를 들어, 체크박스와 레이블이 함께 동작해야 할 때, 체크박스의 상태가 바뀌면 레이블도 그 상태를 반영해야 함

이러한 **상호작용**을 쉽게 관리하기 위해 Compound Component 패턴이 사용된다. 부모 컴포넌트는 상태 변화를 중앙에서 관리하고, 자식 컴포넌트들이 이 상태에 맞춰 자신들의 역할을 수행한다. 덕분에 컴포넌트 간의 **협력**이 자연스럽게 이루어지고, 유지보수 또한 간편해진다.

### 2-2. 상태 공유 문제 해결

React 애플리케이션에서 여러 컴포넌트가 동일한 상태나 로직에 의존할 때가 많다. 이때, 상태나 로직을 여러 자식 컴포넌트에 일일이 전달하는 것은 비효율적일 수 있다. 특히 **props drilling**(상위 컴포넌트에서 하위 컴포넌트로 연속적으로 props를 전달하는 과정)은 코드 가독성을 떨어뜨리고 유지보수를 어렵게 만든다.

**Compound Component 패턴**은 이 문제를 해결하기 위해 부모 컴포넌트가 상태를 관리하고, 자식 컴포넌트는 Context API나 props를 통해 이 상태에 접근

<aside>
🤔

상태를 공유하면서 독립적으로 컴포넌트의 역할을 할 수 있는 방법은 많은데 왜 굳이 복잡한 **Compound Component 패턴**을 사용해야할까? 여러 컴포넌트를 찍어내거나 옵셔널체이닝 혹은  조건부 렌더링 으로 독립적인 역할을 수행할 수 있게하면 안되는 걸까?

</aside>

간단한 예시로 들어보자 

아래 방식은 조건부랜더링 방시으로 useState로 탭의 상태를 관리하고, 
선택된 탭에 다른 컨텐츠를 조건부로 렌더링한다.

```jsx
import React, { useState } from 'react';

const TabComponent = () => {
  const [activeTab, setActiveTab] = useState(0);

  return (
    <div>
      <div>
        <button onClick={() => setActiveTab(0)}>Tab 1</button>
        <button onClick={() => setActiveTab(1)}>Tab 2</button>
      </div>

      {/* 조건부 렌더링을 통해 탭의 내용 보여주기 */}
      <div>
        {activeTab === 0 ? (
          <div>Tab 1 Content</div>
        ) : activeTab === 1 ? (
          <div>Tab 2 Content</div>
        ) : null}
      </div>
    </div>
  );
};

export default TabComponent;
```

### **설명**:

- `useState`로 현재 활성화된 탭(`activeTab`)을 관리
- 버튼 클릭 이벤트에 따라 `activeTab` 값을 변경하고, 조건부 렌더링으로 해당 탭에 맞는 내용을 보여줌

### **한계**:

- **유연성 부족**: 탭과 컨텐츠가 하나의 컴포넌트 안에 tightly coupled(강하게 결합)되어 있음 만약 탭에 새로운 동작을 추가하거나, 추가적인 탭을 동적으로 생성해야 한다면 코드를 많이 수정해야 함
- **재사용성 부족**: 탭과 관련된 로직이 고정되어 있어서 다른 곳에 사용하기 어렵고 옵셔널 체이닝으로 관리한다 해도 유지보수 측면에서 깔끔한 방향은 아님

```jsx
import React, { useState, createContext, useContext } from 'react';

// 1. Context 생성
const TabsContext = createContext();

// 2. Tabs 부모 컴포넌트
const Tabs = ({ children }) => {
  const [activeTab, setActiveTab] = useState(0);

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div>{children}</div>
    </TabsContext.Provider>
  );
};

// 3. Tab 버튼 컴포넌트
const Tab = ({ index, children }) => {
  const { activeTab, setActiveTab } = useContext(TabsContext);

  return (
    <button
      onClick={() => setActiveTab(index)}
      style={{ fontWeight: activeTab === index ? 'bold' : 'normal' }}
    >
      {children}
    </button>
  );
};

// 4. TabPanel 컴포넌트 (탭 내용)
const TabPanel = ({ index, children }) => {
  const { activeTab } = useContext(TabsContext);
  return activeTab === index ? <div>{children}</div> : null;
};

// 사용 예시
const CompoundTabComponent = () => {
  return (
    <Tabs>
      <div>
        <Tab index={0}>Tab 1</Tab>
        <Tab index={1}>Tab 2</Tab>
      </div>

      <TabPanel index={0}>Tab 1 Content</TabPanel>
      <TabPanel index={1}>Tab 2 Content</TabPanel>
    </Tabs>
  );
};

export default CompoundTabComponent;
```

### **설명**:

- **`Tabs` 컴포넌트**는 부모 역할을 하며, 상태(`activeTab`)를 관리하고 그 상태를 자식 컴포넌트들에게 전달
- **`Tab` 컴포넌트**는 버튼으로, 현재 선택된 탭을 보고 강조 표시를 하거나 새로운 탭을 선택.
- **`TabPanel` 컴포넌트**는 `Tabs` 상태에 맞춰 적절한 탭의 내용을 보여줌.

### **장점**:

- **유연성**: `Tabs`, `Tab`, `TabPanel`을 각각 독립적으로 사용할 수 있으며, 다양한 조합이 가능
- **확장성**: 새로운 탭이나 패널을 추가하는 것이 매우 간단. 단순히 `Tab`과 `TabPanel`을 추가하면 됨
- **재사용성**: 각각의 컴포넌트는 독립적이기 때문에 다른 곳에서도 쉽게 재사용할 수 있음
- **상태 중앙화**: 상태 관리가 중앙에서 이루어지므로, 여러 자식 컴포넌트들이 상태를 공유하면서도 역할에만 집중할 수 있음

결국 아래와 같은 **Compound Component 패턴 장점**을 나열할 수 있다.

유연성:

- **옵셔널 체이닝/조건부 렌더링 방식**: 상태와 렌더링이 하나의 컴포넌트에 묶여 있어, 새로운 탭이나 로직을 추가할 때 코드가 복잡해질 수 있음.
- **Compound Component 패턴**: 상태는 부모 컴포넌트에서 중앙에서 관리하고, 각각의 자식 컴포넌트는 그 상태에 맞춰 독립적으로 동작하므로, 새로운 기능을 쉽게 추가할 수 있음.

재사용성:

- **옵셔널 체이닝/조건부 렌더링 방식**: 로직이 하나의 컴포넌트에 모두 포함되어 있어, 이 컴포넌트를 다른 곳에서 재사용하기 어려움.
- **Compound Component 패턴**: `Tab`과 `TabPanel`은 상태에 맞춰 동작하는 독립적인 컴포넌트이므로, 다른 상황에서도 재사용이 가능함.

상태 관리:

- **옵셔널 체이닝/조건부 렌더링 방식**: 상태가 특정 조건에 따라 렌더링과 직접 연결되어 있어, 상태 관리가 단순하지만 복잡한 동작이 필요한 경우 코드 중복이 발생할 수 있음.
- **Compound Component 패턴**: 상태를 중앙에서 관리하며, 자식 컴포넌트들이 그 상태에 맞춰 독립적으로 동작함. 상태와 UI 로직이 분리되어, 더 명확하고 유지보수가 쉬운 코드를 작성할 수 있음.

확장성:

- **옵셔널 체이닝/조건부 렌더링 방식**: 새로운 탭이나 추가 기능을 넣으려면 기존 로직을 수정해야 하며, 확장하는 데 한계가 있음.
- **Compound Component 패턴**: 새로운 탭이나 동작을 추가하는 것이 매우 쉬움. 각각의 역할이 독립적으로 분리되어 있어, 구조를 쉽게 확장할 수 있음.

## 3. **언제 이 패턴을 사용해야 할지, 언제 사용하지 말아야 할지**

| 사용해야할때 | 사용하지 말아야 할 때 |
| --- | --- |
| 여러 자식 컴포넌트가 동일한 상태를 공유하고, 그 상태에 따라 상호작용해야 할 때. 예: 탭(Tab) UI, 아코디언(Accordion), 모달(Modal). | 전역 상태 관리가 필요한 경우. 상태가 부모-자식 간에만 공유되지 않고 애플리케이션 전반에 걸쳐 사용되는 경우. |
| 컴포넌트의 유연성과 확장성이 중요한 경우. 자식 컴포넌트가 독립적으로 동작하며, 상태를 참조해 자유롭게 추가/삭제가 가능할 때. | 상호작용이 단순한 경우. 단일 컴포넌트에서 상태를 관리하고 간단히 렌더링을 제어할 수 있는 상황에서는 오버엔지니어링이 될 수 있음. |
| 재사용 가능한 컴포넌트를 만들고 싶을 때. 독립적으로 설계된 컴포넌트를 여러 곳에서 재사용할 수 있음. | 퍼포먼스가 중요한 대규모 애플리케이션에서. 빈번한 상태 변경과 대규모 UI 트리로 인해 불필요한 리렌더링이 발생할 수 있음. |
| 상태와 UI 로직을 분리하여, 코드의 가독성과 유지보수성을 높이고 싶을 때. | 성능 최적화가 필요한 경우, 상태 관리 방법을 더욱 신중하게 선택해야 함. |

이 패턴은 **코드의 일관성**을 높이고, 각 컴포넌트가 자신의 역할에만 집중하도록 도와준다. 부모 컴포넌트에서 **상태를 중앙에서 관리**하고, 자식 컴포넌트는 그 상태에 따라 동작하므로 **유지보수성**이 크게 향상된다. 새로운 기능을 추가하거나 확장할 때도 **복잡한 로직을 단순화**할 수 있으며, 컴포넌트를 재사용하기 쉬운 구조를 제공한다.

귀찮다는 핑계로 이런 구조를 공부 안해봤는데 재사용성이 높은 modal, dropdown 같은 컴포넌트의 경우 실무에서도 많이 쓰이니 한번 적용해보면 재밌을 것 같당
